# -*- coding: utf-8 -*-
"""hw3_이의준_2020105643.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uzpRP4hZf8NglkGlG3RjzO0Q1udEVxvu
"""

################################## A1 ###################################

def split(values, first, last, count):
        pivotItem = values[first]
        j = first
        for i in range(first+1, last+1):
            if values[i] < pivotItem:
                count[0] += 1   # 데이터 비교 횟수 카운트
                j += 1
                values[i], values[j] = values[j], values[i] # swap
        pivotPoint = j
        values[first], values[pivotPoint] = values[pivotPoint], values[first]   # swap
        return pivotPoint

def _quick_sort(values, first, last, count):
    if first < last:
        pivotPoint = split(values, first, last, count)
        _quick_sort(values, first, pivotPoint-1, count)
        _quick_sort(values, pivotPoint+1, last, count)

def quick_sort(values):
    first = 0
    last = len(values)-1
    count = [0]     # 데이터 비교 횟수(if (s[i]<pivotItem), call by reference를 위해 list에 값을 넣었음
    _quick_sort(values, first, last, count)

    return count[0]

import numpy as np
from random import randrange

################################## quick sort test ###################################
print('################################## quick sort test ###################################')
n = 100
X = [randrange(0, n+1) for i in range(n)]
print(len(X))
print(X)
cnt = quick_sort(X)
print(X)
print(cnt)  # 비교횟수

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
# Colab에서 바로 그래프를 볼 수 있도록 함
# %matplotlib inline

print('################################## A1 ###################################')

N = [100*i for i in range(1,5)]
iter = 100
AVG_CNT = []    # n값에 따른 평균 비교횟수

for n in N:
    avg_cnt = 0
    for i in range(iter):   # 데이터 100 set 생성
        X = [randrange(0, n+1) for j in range(n)]   # 0부터 n까지의 수 중에서 n개를 중복을 허락하여 뽑겠다
        cnt = quick_sort(X)
        avg_cnt += cnt

    avg_cnt /= iter
    AVG_CNT.append(avg_cnt)

print(AVG_CNT)
plt.xlim(N[0]-20, N[-1]+20) # plot할 x의 범위
#plt.ylim(200, 400)          # plot할 y의 범위
plt.plot(N, AVG_CNT, linewidth=2, c='r')    # n과 평균 비교횟수를 잇는 선
plt.scatter(N, AVG_CNT, s=40, c='k')    # 평균 비교횟수를 좌표위에 나타냄
plt.xlabel("n")
plt.ylabel("Average number of comparisons")
plt.grid(True)

plt.show()

#### 보고서의 답변에서 사용한 코드

# nlog = []   # nlog2(n)값 저장
# for n in N: # N = [100, 200, 300, 400]
#     nlog.append(n*np.log2(n))

# print(nlog)
# print(AVG_CNT)
# print()

# for i in range(1, len(N)):   # 증가율 비교
#     print(AVG_CNT[i] / AVG_CNT[i-1], nlog[i]/nlog[i-1])

################################## A2 ###################################

def prod2(u, v, threshold=2):
    n = max(len(str(u)), len(str(v)))   # 자릿수 계산을 위해 u, v를 문자로 변환하여 길이 계산

    if (u == 0 or v == 0):      return 0
    elif n <= threshold:        return u * v
    else:
        m = int(n/2)    # n/2의 마루함수값
        x, y = int(u / (10**m)), u % (10**m)    # n/2자리씩 분리
        w, z = int(v / (10**m)), v % (10**m)    # n/2자리씩 분리

        # 개선된 큰 수의 곱셈 알고리즘 (곱셈횟수 4번 -> 3번)
        r = prod2(x+y, w+z)
        p = prod2(x, w)
        q = prod2(y, z)

        return p*pow(10, 2*m) + (r-p-q)*pow(10, m) + q

########################## prod2 test ####################################
print('########################## prod2 test ####################################')
a = randrange(10000, 999999)
b = randrange(10000, 999999)
print(a, b)
print(prod2(a,b))   # 큰 수의 곱셈
print(a*b)          # 일반적인 곱셈