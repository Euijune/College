# -*- coding: utf-8 -*-
"""PP11.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nHvAxUzi8Q1HR_Z3OEddeH3NDBpzf81f

## Bubble Sort
"""

def bubble_up2(values, start, end):
    for indx in range(end, start, -1):
        if values[indx] < values[indx-1]:
            values[indx], values[indx-1] = values[indx-1], values[indx]

def bubble_sort(values):
    curr = 0
    num_val = len(values)
    while curr < num_val:
        bubble_up2(values, curr, num_val - 1)
        curr += 1

"""## Heap Sort"""

def reheap_down(elements, root, bottom):
    leftChild = root*2 + 1
    rightChild = root*2 + 2

    if leftChild <= bottom:
        if leftChild == bottom:
            maxChild = leftChild
        else:
            if elements[leftChild] <= elements[rightChild]:
                maxChild = rightChild
            else:
                maxChild = leftChild
        if elements[root] < elements[maxChild]:
            elements[root], elements[maxChild] = elements[maxChild], elements[root]
            reheap_down(elements, maxChild, bottom)

def heap_sort(values, numValues):
    for indx in range(numValues//2  -1, -1, -1):
        reheap_down(values, indx, numValues-1)

    for indx in range(numValues-1, 0, -1):
        values[0], values[indx] = Swap(values[0], values[indx])
        reheap_down(values, 0, indx-1)

"""## Insertion Sort"""

def insert_item(values, start, end):
    finished = False
    curr = end
    moreToSearch = (curr != start)

    while moreToSearch and not finished:
        if values[curr] < values[curr-1]:
            values[curr], values[curr-1] = values[curr-1], values[curr]
            curr -= 1
            moreToSearch = (curr != start)
        else:
            finished = True

def insertion_sort(values):
    num_val = len(values)
    for count in range(0, num_val):
        insert_item(values, 0, count)

"""## Merge Sort"""

def merge_sort(values, first, last):
    if first < last:
        middle = (first + last) // 2
        merge_sort(values, first, middle)
        merge_sort(values, middle+1, last)
        merge(values, first, middle, middle+1, last)

def merge(values, leftFirst, leftLast, rightFirst, rightLast):
    tmp_arr = [None] * 1000
    indx = leftFirst
    save_1st = leftFirst

    while (leftFirst <= leftLast) and (rightFirst <= rightLast):
        if values[leftFirst] < values[rightFirst]:
            tmp_arr[indx] =  values[leftFirst]
            leftFirst += 1
        else:
            tmp_arr[indx] = values[rightFirst]
            rightFirst += 1
        indx += 1
    
    while leftFirst <= leftLast:
        tmp_arr[indx] = values[leftFirst]
        leftFirst += 1
        indx += 1
    
    while rightFirst <= rightLast:
        tmp_arr[indx] = values[rightFirst]
        rightFirst += 1
        indx += 1

    for indx in range(save_1st, rightLast+1):
        values[indx] = tmp_arr[indx]

"""## Quick Sort"""

def split(values, first, last):
    split_val = values[first]
    save_1st = first

    first += 1
    while True:
        onCorrectSide = True
        while onCorrectSide:
            if values[first] > split_val:
                onCorrectSide = False
            else:
                first += 1
                onCorrectSide = (first <= last)
        
        onCorrectSide = (first <= last)
        while (onCorrectSide):
            if values[last] <= split_val:
                onCorrectSide = False
            else:
                last -= 1
                onCorrectSide = (first <= last)

        if first < last:
            values[first], values[last] = values[last], values[first]
            first += 1
            last -= 1

        if first > last:
            break
    
    split_point = last
    values[save_1st], values[split_point] = values[split_point], values[save_1st]

    return split_point
    
def quick_sort(values, first, last):
    if first < last:
        split_point = split(values, first, last)
        quick_sort(values, first, split_point-1)
        quick_sort(values, split_point+1, last)

"""## Selection Sort"""

def min_index(values, start, end):
    min_indx = start
    for indx in range(start+1, end+1):
        if values[indx] < values[min_indx]:
            min_indx = indx

    return min_indx

def selection_sort(values):
    num_val = len(values)
    end = num_val - 1
    for curr in range(0, end):
        min_indx = min_index(values, curr, end)
        values[curr], values[min_indx] = values[min_indx], values[curr]

"""## Short Bubble Sort"""

# bubble_up : short bubble sort, bubble_up2 = bubble sort
def short_bubble(values, numValues):
    curr = 0
    sorted = False
    while curr < numValues-1 and not sorted:
        sorted = bubble_up(values, curr, numValues-1, sorted)
        curr += 1

def bubble_up(values, startIndex, endIndex, sort):
    sort = True
    for indx in range(endIndex, startIndex, -1):
        if values[indx] < values[indx-1]:
            values[indx], values[indx-1] = values[indx-1], values[indx]
            sort = False

    return sort

"""# **Test**"""

if __name__ == '__main__':
    arr = [0,8,5,4,6,2,7,1,3,9]
    bubble_sort(arr)
    print(arr)
    
    arr = [0,8,5,4,6,2,7,1,3,9]
    heap_sort(arr, len(arr))
    print(arr)

    arr = [0,8,5,4,6,2,7,1,3,9]
    insertion_sort(arr)
    print(arr)

    arr = [0,8,5,4,6,2,7,1,3,9]
    merge_sort(arr, 0, len(arr)-1)
    print(arr)

    arr = [0,8,5,4,6,2,7,1,3,9]
    quick_sort(arr, 0, len(arr)-1)
    print(arr)
        
    arr = [0,8,5,4,6,2,7,1,3,9]
    selection_sort(arr)
    print(arr)

    arr = [0,8,5,4,6,2,7,1,3,9]
    short_bubble(arr, len(arr))
    print(arr)